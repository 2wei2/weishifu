​         网安逆向wp作业
![](img/NOTES2022-01-22-18-22-30.png)
1.
点击附录将程序拖入ida中:再找main函数，按f5一条龙服务得到伪代码：
![](img/NOTES2022-01-22-18-23-20.png)
对该程序进行判断:我们倒着来分析啊，首先去寻找关键字看有没有flag，congratulations，或者success之类的，发现出现了success（其实到这里后面的v7的含义我都还不是很懂，但大概能猜出她的意思）。然后我们继续往上找，发现有个if的判断条件，证明v10要与v13相等，往上看，我们发现v13数组储存的数据我们是知道的，同时v10的值与Buffer有关，而Buffer又与v4有关，v4的值又是v9赋得的，而v9又是我们输入的值，所以最后就是v9==v13。最后把16进制转化为字符串：![](img/NOTES2022-01-22-18-23-46.png)
最后得到结果。


2.
![](img/NOTES2022-01-22-18-24-06.png)
将文档拖入ida中处理，找main函数转伪代码得到这个结果：
![](img/NOTES2022-01-22-18-24-40.png)
开始我陷入了困境，因为根本找不到与scanf函数有关的读取函数，其他的也不认识。于是想办法就多点点，然后点到了strs函数![](img/NOTES2022-01-22-18-25-16.png)
然后我的老天爷啊，我看见了flag{}于是找上去发现她出现了：{this_is_flag};到这里战斗结束。
3.
python trade
开始我看到这个python我拒绝的，后来抱着试一试的心态把它的源程序拖到了ida里，结果![](img/NOTES2022-01-22-18-26-06.png)
完蛋了，，连main函数都找不到，之后看了看攻略(╯‵□′)╯︵┻━┻，发现需要特定的反汇编工具.....![](img/NOTES2022-01-22-18-26-25.png)
输入文件后得到伪代码，说实话我本来看不懂python，但揣摩了一下后大概知道了他什么意思，因为有input（）的输入函数，那flag这个变量就是我们的重点了之后发现想要打印“correct”的话需要我们输入的字符与correct变量的内容相同，因此我们再往上找，发现correct是已知量，但是上面有一个函数的形式，因为出现了return而后面出现函数的只有raw_input（）因此推测上面的函数会将输入的信息加密处理。观察后发现，是将原信息先与32异或再自增16最后把所以的数据储存给s再return传递出来。那么我们以此来编写脚本。因为小阿伟不会python，就只能用c语言来写了![](img/NOTES2022-01-22-18-27-00.png)
注意这里字符数组a里面的值是结果一次处理的，需要base64转码一次（之前不知道霍霍了半天），然后再循环依次自减异或处理，最后打印flag：![](img/NOTES2022-01-22-18-27-36.png)
好了，战斗结束。
4.
re1
将源程序拖入ida中：![](img/NOTES2022-01-22-18-28-47.png)
还是倒着看，发现有一个是aFlag，有一个是aFlagGet；点击进入他们的地址，发现其中aFlag出现的是“不太对哦，再试试呗，加油哟”，而另一个是“正确”因此我们对v9的处理需要得到下面的那个flag，对条件运算符进行分析，发现到达三目运算符之后无论怎样v3都不等于0，因此我们不能到达条件运算符，因此之前的那个if（v3）里面v3必须为0，那么strcmp比较函数里面v9要与v5相等，那么再对v5地址的值寻找：![](img/NOTES2022-01-22-18-29-04.png)
最后发现了该数据，因为尾号是h所以是是16进制，我们把它转为字符：![](img/NOTES2022-01-22-18-30-00.png)
得到以下结果，发现大括号只有一半，而v6与v5地址紧挨着，而且数据没用到，因此把v6的数据也处理：![](img/NOTES2022-01-22-18-30-17.png)
最后连起来得到结果:DUTCTF{We1c0met0DUTCTF} 
而且最后的换向是我没有想到的，我承认看了一下攻略.....
5.
game 
（写这题时听的歌是：New Boy 房东的猫）
这题是个游戏题，虽然开始我选计算机也是为了造游戏.....结果发现太难了：![](img/NOTES2022-01-22-18-30-42.png)
翻译了大概的意思就是要输入一串数，使灯亮再得到flag
我们把她拖入ida里安排：![](img/NOTES2022-01-22-18-30-59.png)
然后出现了这样的界面，虽然还是不懂每个部分的意思，但相对来讲也是混了个脸熟；但问题再与我们不好找main函数(╯‵□′)╯︵┻━┻，因为按照吴敢的步骤要先找main函数再按f5转c语言，在不断地往下翻之后，我放弃了orz。。。
  再去寻找其他的方法：![](img/NOTES2022-01-22-18-31-41.png)
先找到左边的function name再按ctrl+f搜索函数：main![](img/NOTES2022-01-22-18-34-59.png)
现在总算把她逮住了嘿嘿嘿：按f5转c语言后便得到了我们想要的主函数：![](img/NOTES2022-01-22-18-35-27.png)
![](img/NOTES2022-01-22-18-35-46.png)
通过观察if的判断条件，我们发现这里就是满座8个灯都亮的条件那么后面的那个sub_457AB4就是我们的目标了！
![](img/NOTES2022-01-22-18-36-05.png)
进入后得到以下界面：
![](img/NOTES2022-01-22-18-36-25.png)
我们直接观察最后的for语句，到这里思路就很清晰了：由两个数组内的元素相互异或运算，再与0x13异或，并将最后的结果打印出来就是flag了。o(￣ヘ￣o＃)![](img/NOTES2022-01-22-18-36-47.png)
写脚本后运算得到flag。战斗结束。
6.
logmein
​   (写这题时听歌：青柠——徐秉龙/桃十五)
将原程序拖入ida中
![](img/NOTES2022-01-22-18-37-30.png)
观察后发现思路很简单：属于典型的密码输入，而s是用储存我们输入的数据的。而唯一的运算在于后面for循环的异或运算，其中有一个v8[i%7-8]，如果直接算的话那数组的下标不就是负数了吗？没事是负数就往前面找，v8前面是v7，而v7又是16进制的数据。数据在内存中储存的时候是会按字节分段的。所以我们把它转化为字符形式：![](img/NOTES2022-01-22-18-37-55.png)
在分析了其他人的wp后知道这里存储要翻过来一次：数据位数大的放在高位储存，所以开始的数据其实被粗存在后面的地址。真正的地址排序其实是反过来的。然后我们写出脚本得到最后的flag：![](img/NOTES2022-01-22-18-38-08.png)![](img/NOTES2022-01-22-18-38-22.png)
战斗结束。
7.
open source
​            （阅读时听歌：Oops）
![](img/NOTES2022-01-22-18-38-59.png)
这题不需要用ida去反汇编，因为源码已经直接给出来了，emm可以说是梦开始的地方，因为这就是伟接触的第一个逆向题，好像就是学长你讲的.....；思路其实也很清晰：为了不出现sorry或者wrong，if里的判断条件就需要达到，所以first就是16进制的cafe，而second要同时满足对5取余数不能是3，同时对17取余数要是8，那么就是25了。而strcmp函数要的0，就需要“h4cky0u”与argv数组相等；那么我们最后写出脚本：![](img/NOTES2022-01-22-18-39-15.png)
好了，战斗结束；

8.
getit
![](img/NOTES2022-01-22-18-39-28.png)
这题的核心是for循环中s对t的赋值。而他们的数据伪代码并没有直接给出，因此我们点击进入地址中：![](img/NOTES2022-01-22-18-39-43.png)
此处两者的信息便找到了，我们再根据伪代码写出脚本：
![](img/NOTES2022-01-22-18-40-03.png)
最后得到flag。![](img/NOTES2022-01-22-18-40-21.png)
